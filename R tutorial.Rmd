---
title: "A primer on data analysis and visualization in R"
author: "Eliot McKinley"
date: "9/24/2021"
output: html_document
---
## Introduction

This tutorial gives examples of some common statistical and data visualization techiniques that you ay be used to in Excel or Prism using R. The advantages of using R include the abiility to work with larger data sets, better control of you analysis methods, the availability of online tutorials and primers for almost anything you'd like to do, and, most importantly, everything will look better than using Excel or Prism.

Topics include:
1. Loading Data
2. Exploring and Summarizing Data
3. Saving Data
4. Basic Data Visualization
5. T-tests, Wilcoxon tests, and ANOVA
6. Correlations
7. PCA and Dimensionality Reduction
8. Advanced Data Visualization
9. Making publication quality plots and panels

We will be working in the tidyverse, which is an ecosystem for data science. https://www.tidyverse.org/

We will be making all plots using the package {ggplot2} rather than the base R plotting. {ggplot2} provides an intuitive and powerful system for data visualization that is more flexible and beautiful than base R.

First we will install (if necessary) and load the tidyverse and palmerpenguins packages.

```{r setup}
# check if packages are loaded 
packages = c("tidyverse", "palmerpenguins")
if (length(setdiff(packages, rownames(installed.packages()))) > 0) {
  install.packages(setdiff(packages, rownames(installed.packages())))
}
library(tidyverse)
library(palmerpenguins)
```

## 1. Loading data

We are going to use the Palmer Penguins data set which is included in the package {palmerpenguins}. When the package is loaded you have access to the variable "penguins" which contains this data. You can assign it to a different variable name.

```{r cars}
my_penguins = penguins
```

More often your data is not available from a package so you need to read the data in to R. If your data is saved as a csv file you can pass the file path to your data into the read_csv function in order to import into R. 

```{r}
my_penguins_csv = read_csv("./penguins.csv" ,)
```

read_csv() prints the names and data types of each column in the csv file.

If your data is saved as an Excel file, you have to install and load another library first, {redxl}. Then call the read_excel funtion

```{r}
packages = c("readxl")
if (length(setdiff(packages, rownames(installed.packages()))) > 0) {
  install.packages(setdiff(packages, rownames(installed.packages())))
}
library(readxl)

my_penguins_excel = read_excel("penguins.xlsx")
```

There are packages available to read all types of data, including fcs files for flow cytometry {flowCore} and google sheets {googlesheets4}, 

## 2. Exploring and Summarizing Data

Now that our data is loaded into R, we can do stuff with it. As all the data sets that we imported are identical, we will just stick with "my_penguins". These are in the format of data frames.

There are a few different ways to view your data.

head(data) will show you the first 6 rows of data, or head(data, n) will show you n rows of data.

```{r}
head(my_penguins)
head(my_penguins, 10)
```

You can view all the data using View(data), or by clicking on the variable name in the "Environment" window in the upper right corner of RStudio. This may take a while if your data set is very large.

```{r}
View(my_penguins)
```

glimpse() gives you a bit more information
```{r}
glimpse(my_penguins)
```

summary() will give you some general summary info for each of your variables.

```{r}
summary(my_penguins) 
```

You can also do your own summaries. This will utilize the dplyr package which provides many powerful tools to manipulate your data frames. In this case let's say we want to group the penguins by species and then calculate the mean and standard deviation for each species:

```{r}
my_penguins %>%  # %>% is a pipe, it applies a function to the data prior, in this case "my_penguins"
  group_by(species) %>% #this specifies species as the group
  summarize( #summarize specifies that you want to summarise each group
    mean_bill = mean(bill_length_mm, na.rm = TRUE), #na.rm will ignore any NAs in the data
    std_bill = sd(bill_length_mm, na.rm=TRUE))
```

dplyr has many operators summarized in this cheat sheet: https://github.com/rstudio/cheatsheets/raw/master/data-transformation.pdf

Let's say you want to summarize based upon species and year, it is as simple as adding year to your group_by() function call.

```{r}
my_penguins %>%  # %>% is a pipe, it applies a function to the data prior, in this case "my_penguins"
  group_by(species, year) %>% #this specifies species and year as the group
  summarize( #summarize specifies that you want to summarise each group
    mean_bill = mean(bill_length_mm, na.rm = TRUE), #na.rm will ignore any NAs in the data
    std_bill = sd(bill_length_mm, na.rm=TRUE))
```

There are plenty of other things you can do with dplyr. For example, if you want to get rid of data earlier than 2008, you can filter by year.

```{r}
my_penguins %>%  # %>% is a pipe, it applies a function to the data prior, in this case "my_penguins"
  filter(year >= 2008) %>% #this filters out years prior to 2008
  group_by(species, year) %>% #this specifies species as the group
  summarize( #summarize specifies that you want to summarize each group
    mean_bill = mean(bill_length_mm, na.rm = TRUE), #na.rm will ignore any NAs in the data
    std_bill = sd(bill_length_mm, na.rm=TRUE))
```

## 3. Saving Data

When creating summary tables above, we didn't assign them to a variable, so they were printed to the console. If we assign them to "my_penguins_summary" we now have a new variable that you may want to save for later use.

```{r}
my_penguins_summary = my_penguins %>%  # %>% is a pipe, it applies a function to the data prior, in this case "my_penguins"
  filter(year >= 2008) %>% #this filters out years prior to 2008
  group_by(species, year) %>% #this specifies species as the group
  summarize( #summarize specifies that you want to summarize each group
    mean_bill = mean(bill_length_mm, na.rm = TRUE), #na.rm will ignore any NAs in the data
    std_bill = sd(bill_length_mm, na.rm=TRUE))
```

The most common way to save data is as a csv file. A csv file is versitile and can be read in any number of programs including Excel. In order to save a csv file we will use the write_csv function. You need to specify which variable you want to save and a path and/or filename to save it to.

```{r}
write_csv(my_penguins_summary, "penguins summary.csv")
```

If you have large data sets and will continue working in R with them, it may be advantageous to save as an RDS file. RDS files compress data better than csv for large files so can save space and can also be opened quicker than a csv using readRDS().

```{r}
saveRDS(my_penguins_summary, "penguins summary.rds")
```

## 4. Basic Data Visualization

As mentioned before, we will be skipping plotting with base R and using {ggplot2} instead. ggplot2 works by layering plots (geoms) and annotations on a common coordinate system. There are many different built in plot types available including scatter splots, bar plots, box plots, dot plots, and violin plots. 

A fantastic ggplot2 tutorial by Cedric Sherer can be found here: https://cedricscherer.netlify.app/2019/08/05/a-ggplot2-tutorial-for-beautiful-plotting-in-r/

A cheat sheet of avaiable geoms and other helpful hints is here: 
https://github.com/rstudio/cheatsheets/raw/master/data-visualization.pdf

We will start just plotting each replicate of bill length for each penguin species.

```{r}
my_penguins %>%  # start with the data you want to plot
  ggplot(aes(x = species, y = bill_length_mm ))+ # you have to establish aesthetics, in this case the x and y variables, to add another layer you use a "+"
  geom_point() # this adds each data point, NAs will be excluded
```

Box plots are created similarly

```{r}
my_penguins %>%  # start with the data you want to plot
  ggplot(aes(x = species, y = bill_length_mm ))+ # you have to establish aesthetics, in this case the x and y variables, to add another layer you use a "+"
  geom_boxplot() # this creates box plots, NAs will be excluded
```

Violin plots

```{r}
my_penguins %>%  # start with the data you want to plot
  ggplot(aes(x = species, y = bill_length_mm ))+ # you have to establish aesthetics, in this case the x and y variables, to add another layer you use a "+"
  geom_violin() # this creates violin plots, NAs will be excluded
```

If you try to make a bar plot with geom_bar(), you will get an error since you can't have an x and y aesthetics without specifying a transformation or "stat". Stat identity will add up all the bill lenghts, which is likely not what you want.

```{r}
my_penguins %>%  # start with the data you want to plot
  ggplot(aes(x = species, y = bill_length_mm ))+ # you have to establish aesthetics, in this case the x and y variables, to add another layer you use a "+"
  geom_bar(stat="identity") # this creates bar plots, NAs will be excluded
```

To get a bar plot like you normally expect, with averages on the y-axis instead of sums, you use stat_summary which defaults to the mean.

```{r}
my_penguins %>%  # start with the data you want to plot
  ggplot(aes(x = species, y = bill_length_mm ))+ # you have to establish aesthetics, in this case the x and y variables, to add another layer you use a "+"
  stat_summary(geom="bar") # this creates bar plots, NAs will be excluded
```

You can add an error bar with another call to stat_summary, here it defaults to mean and standard error. Note that I put it above the bar function call so that the bar would be plotted on top of the errorbar. Order matters with {ggplot2}.

```{r}
my_penguins %>%  # start with the data you want to plot
  ggplot(aes(x = species, y = bill_length_mm)) + # you have to establish aesthetics, in this case the x and y variables, to add another layer you use a "+"
  stat_summary(geom = "errorbar") + #adds an error bar with se as the range
  stat_summary(geom = "bar")  # this creates bar plots, NAs will be excluded
  
```

However, **I highly recommend you do not use these types of plots**, especially in publications. Bar plots hide the real distribution and number of replicates of the data and there are better ways to visualize data that will be discussed later.

For time series data, you can change the x-axis to "year" and can add a color aesthetic to differentiate the penguin species and a line connecting the mean values.

```{r}
my_penguins %>%  # start with the data you want to plot
  ggplot(aes(x = year, y = bill_length_mm, color=species)) + # you have to establish aesthetics, in this case the x and y variables as well as color for the species
  geom_point()+ # this creates points plots, NAs will be excluded+
  geom_line(stat="summary") #this creates lines from each mean for species and year
  
```

To save a plot, use the ggsave function. It will automatically save the last plot generated, or if you save a plot to a variable, you can specify which plot to save. You can specify image size as well.

```{r}
ggsave("last plot.png")

plot_to_save = my_penguins %>%  # start with the data you want to plot
  ggplot(aes(x = species, y = bill_length_mm ))+ # you have to establish aesthetics, in this case the x and y variables, to add another layer you use a "+"
  geom_violin(aes(color=species)) # this creates violin plots, NAs will be excluded

ggsave("specific plot.png", plot = plot_to_save, width=5, height=5)

```

## 5. T-tests and Wilcoxon tests

To run a t-test, you need two vectors to compare. If these are already columns in your data, then this is easy. Just use t.test() and pass the two columns. If the data is paired, you add "paired = TRUE".

```{r}
t.test(my_penguins$bill_length_mm, my_penguins$body_mass_g)
t.test(my_penguins$bill_length_mm, my_penguins$body_mass_g, paired = TRUE)
```

Above, you can see that bill length is highly significantly different than body mass. But that is a nonsensical test, since one is a length and one is a weight. If you wanted to compare bill length between two species, you can just make two new vectors and then run t.test().

```{r}
gentoo = penguins %>% filter(species == "Gentoo") %>% pull(body_mass_g) #pull gives you a vector
chinstrap = penguins %>% filter(species == "Chinstrap") %>% pull(body_mass_g)

t.test(gentoo, chinstrap)
```

Alternatively, you can use parwise_t_test from {rstatix} to get pairwise comparisons between groups.
```{r}
packages = c("rstatix")
if (length(setdiff(packages, rownames(installed.packages()))) > 0) {
  install.packages(setdiff(packages, rownames(installed.packages())))
}
library(rstatix)


my_penguins %>% 
pairwise_t_test(body_mass_g ~ species)
```

To use a non-paremetric test, you do the same thing, but use wilcox.test() or pairwise_wilcox_test()

```{r}
wilcox.test(gentoo, chinstrap)

my_penguins %>% 
pairwise_wilcox_test(body_mass_g ~ species)
```

